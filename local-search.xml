<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>当为 bytes.Buffer 实例使用对象池时应该注意的问题</title>
    <link href="/2021/12/07/problems-when-using-sync-Pool-for-bytes-Buffer/"/>
    <url>/2021/12/07/problems-when-using-sync-Pool-for-bytes-Buffer/</url>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>最近开发的一个项目，后端接收 agent 发送的 BSON 对象反序列化后的字节流，然后将每个对象的字节流写入到 Kafka 中。Kafka SDK 使用的是 sarama。此处使用的是异步生产者，此处将消息实例发送给 <code>kafkaWriter</code> 后，由 SDK 在后台定期发送到 Kafka 中。<code>dataChan</code> channel 中的元素是由 <code>sync.Pool</code> 对象池分配的 <code>bytes.Buffer</code> 实例，接收到的字节流保存在其中，for 循环的结尾会将分配的实例归还到对象池中。</p><p>Kafka 消费者为 Python 开发，会反序列化每条收到的消息。下面是生产者代码，消费者代码未列出。</p><figure class="highlight golang"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s *BrokerServer)</span> <span class="hljs-title">sender</span><span class="hljs-params">(dataChan <span class="hljs-keyword">chan</span> *bytes.Buffer)</span></span> &#123;<br><span class="hljs-keyword">var</span> err error<br><br>kafkaWriter, err := sarama.NewAsyncProducer([]<span class="hljs-keyword">string</span>&#123;s.kafkaAddr&#125;, <span class="hljs-literal">nil</span>)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>s.logger.Fatalf(<span class="hljs-string">&quot;Failed to connect to kafka: %s&quot;</span>, err.Error())<br>&#125;<br><span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">if</span> err := kafkaWriter.Close(); err != <span class="hljs-literal">nil</span> &#123;<br>s.logger.Printf(<span class="hljs-string">&quot;Failed to close kafka writer: %s&quot;</span>, err.Error())<br>&#125;<br>&#125;()<br><br><span class="hljs-keyword">var</span> entry *bytes.Buffer<br><span class="hljs-keyword">for</span> &#123;<br><span class="hljs-keyword">select</span> &#123;<br><span class="hljs-keyword">case</span> entry = &lt;-dataChan:<br>kafkaWriter.Input() &lt;- &amp;sarama.ProducerMessage&#123;<br>Topic: s.kafkaTopic,<br>Key:   <span class="hljs-literal">nil</span>,<br>Value: sarama.ByteEncoder(entry.Bytes()),<br>&#125;<br><span class="hljs-keyword">case</span> kafkaErr := &lt;-kafkaWriter.Errors():<br>s.logger.WithFields(logrus.Fields&#123;<br><span class="hljs-string">&quot;error&quot;</span>: kafkaErr.Error(),<br>&#125;).Error(<span class="hljs-string">&quot;Failed to produce message&quot;</span>)<br><span class="hljs-keyword">case</span> &lt;-s.ctx.Done():<br>s.logger.WithFields(logrus.Fields&#123;<br><span class="hljs-string">&quot;goroutine&quot;</span>: <span class="hljs-string">&quot;sender&quot;</span>,<br>&#125;).Info(<span class="hljs-string">&quot;terminated&quot;</span>)<br><span class="hljs-keyword">return</span><br>&#125;<br><br>bufferPool.Put(entry)<br>&#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="产生的-bug"><a href="#产生的-bug" class="headerlink" title="产生的 bug"></a>产生的 bug</h2><p>消费者在反序列化收到的数据时会随机抛出反序列化异常。</p><h2 id="bug-分析"><a href="#bug-分析" class="headerlink" title="bug 分析"></a>bug 分析</h2><p>首先排除消费者代码存在的 bug，因此可以断定数据在写入到 Kafka 之前就已经不正确了。接着通过调试确定 agent 发送到后端的数据没问题，以及后端写入到 bytes.Buffer 中的数据没问题。最终确定 bug 出现在上文列出的函数中。</p><p>如果你熟练掌握了 <code>bytes.Buffer</code> 以及 <code>slice</code>，很容易发现这个 bug。bug 产生的原因有三：</p><ul><li>此处使用了异步生产者。</li><li><code>bytes.Buffer</code> 实例的 <code>Bytes()</code> 方法返回对底层 slice 的引用。</li><li>因为使用的是异步生产者，因此在将 <code>bytes.Buffer</code> 实例归还到对象池之后、异步生产者将数据发送到 Kafka 之前的这段时间，对象池很可能会将处于异步生产者发送队列中的 bytes.Buffer 实例分配出去，因而数据被修改。</li></ul><h2 id="修复办法"><a href="#修复办法" class="headerlink" title="修复办法"></a>修复办法</h2><p>暂时将异步生产者改为同步生产者，等待 SDK 将消息发送到 Kafka 后把 <code>bytes.Buffer</code> 实例归还给对象池，然后再处理下一条消息。后续再研究一下 sarama 这个库，看看在异步生产者的情况下有无解决办法。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>从这个 bug 可以总结出以下几点：</p><ul><li>使用 <code>sync.Pool</code> 对象池时，一定要在操作完数据之后再将对象归还给对象池，如果提前归还，则会导致对象数据被修改。</li><li><code>bytes.Buffer</code> 实例的 <code>Bytes()</code> 方法返回的是对 slice 的引用，即返回一个 slice，而不是对 slice 底层对应的数组的拷贝。因此注意防止对 <code>bytes.Buffer</code> 的意外修改。</li><li>从对象池获取一个 <code>bytes.Buffer</code> 实例后，应立即调用 <code>Reset()</code> 方法。同时应该了解， <code>Reset()</code> 方法只是将底层 slice 的长度置为 0，而不会释放已经分配给 slice 的内存。因此一定要注意在归还给对象池之前释放所有对 <code>bytes.Buffer</code> 的 slice 引用，一是避免意外的数据修改，二是能够让垃圾收集器及时回收未被使用的内存。</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>Golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>为 sudo 命令启用 Touch ID 和 Apple Watch</title>
    <link href="/2021/10/04/enable-touchid-for-sudo/"/>
    <url>/2021/10/04/enable-touchid-for-sudo/</url>
    
    <content type="html"><![CDATA[<p>在 Mac 上使用 sudo 命令时，可使用 TouchID 和/或 Apple Watch 代替输入密码。</p><h2 id="支持-Touch-ID-的-Mac"><a href="#支持-Touch-ID-的-Mac" class="headerlink" title="支持 Touch ID 的 Mac"></a>支持 Touch ID 的 Mac</h2><p>支持 TouchID 的 Mac 上原生支持使用 TouchID 和 Apple Watch 解锁，执行 sudo 命令时 Touch ID 和 Apple Watch 都会弹出确认对话框，只需要使用一种方式确认即可。</p><p>开启方法：在 PAM 的配置文件 <code>/etc/pam.d/sudo</code> 开头加入以下内容即可：</p><figure class="highlight nginx"><table><tr><td class="gutter hljs hljs hljs hljs hljs hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs nginx"><span class="hljs-attribute">auth</span>       sufficient     pam_tid.so<br></code></pre></div></td></tr></table></figure><h2 id="不支持-Touch-ID-的-Mac"><a href="#不支持-Touch-ID-的-Mac" class="headerlink" title="不支持 Touch ID 的 Mac"></a>不支持 Touch ID 的 Mac</h2><p>不支持 Touch ID 的 Mac 需要安装额外的 PAM 插件 <a href="https://github.com/biscuitehh/pam-watchid">pam-watchid</a> 以使用 Apple Watch。按照 README 中的步骤安装即可。</p><h2 id="在-tmux-中的问题"><a href="#在-tmux-中的问题" class="headerlink" title="在 tmux 中的问题"></a>在 tmux 中的问题</h2><p>如果使用 tmux，就会发现不能使用 Touch ID 或 Apple Watch 解锁。此时需要安装额外的 PAM 插件 <a href="https://github.com/fabianishere/pam_reattach">pam_reattach</a>。使用 Homebrew 可快速安装：</p><figure class="highlight shell"><table><tr><td class="gutter hljs hljs hljs hljs hljs hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">brew install fabianishere/personal/pam_reattach<br></code></pre></div></td></tr></table></figure><p>然后在 <code>/etc/pam.d/sudo</code> 文件的开头加入以下内容即可：</p><figure class="highlight fortran"><table><tr><td class="gutter hljs hljs hljs hljs hljs hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs fortran">auth     <span class="hljs-keyword">optional</span>     pam_reattach.so<br></code></pre></div></td></tr></table></figure><p>注意如果是 M1 Mac 用户，因为 Homebrew 在 M1 上的安装路径为 <code>/opt/homebrew</code>，因此需要指定共享库的绝对路径：</p><figure class="highlight awk"><table><tr><td class="gutter hljs hljs hljs hljs hljs hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs awk">auth     optional     <span class="hljs-regexp">/opt/</span>homebrew<span class="hljs-regexp">/lib/</span>pam/pam_reattach.so<br></code></pre></div></td></tr></table></figure><h2 id="更新系统后"><a href="#更新系统后" class="headerlink" title="更新系统后"></a>更新系统后</h2><p>macOS 在每次更新系统时都会重置系统文件，因此会丢失 <code>/etc/pam.d/sudo</code> 文件的修改。故每次更新系统后都需要重复上述步骤。</p>]]></content>
    
    
    <categories>
      
      <category>工具配置</category>
      
    </categories>
    
    
    <tags>
      
      <tag>macOS</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
