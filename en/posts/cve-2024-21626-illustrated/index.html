<!doctype html><html lang=en><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=robots content="noodp"><title class=pjax-title>Illustrate runC Escape Vulnerability CVE-2024-21626 - Nitro's Blog</title><meta name=Description content="Nitro's Blog"><meta property="og:title" content="Illustrate runC Escape Vulnerability CVE-2024-21626">
<meta property="og:description" content="runC, a container runtime component, published version 1.1.12 to fix CVE-2024-21626 at 31, Jan 2024, which leads to escaping from containers. The range of affected versions are >= v1.0.0-rc93, <=1.1.11. For containerd the fixed versions are 1.6.28 and 1.7.13, the range of affected versions are 1.4.7 to 1.6.27 and 1.7.0 to 1.7.12. For Docker the fixed version is 25.0.2.
RepdoruceMy environment to repdouce it is:
Linux distro: Arch Linux Linux kernel: 6."><meta property="og:type" content="article"><meta property="og:url" content="https://nitroc.org/en/posts/cve-2024-21626-illustrated/"><meta property="og:image" content="https://nitroc.org/logo.png"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-02-06T21:31:14+08:00"><meta property="article:modified_time" content="2024-02-16T17:22:10+08:00"><meta property="og:site_name" content="Nitro's Blog"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://nitroc.org/logo.png"><meta name=twitter:title content="Illustrate runC Escape Vulnerability CVE-2024-21626"><meta name=twitter:description content="runC, a container runtime component, published version 1.1.12 to fix CVE-2024-21626 at 31, Jan 2024, which leads to escaping from containers. The range of affected versions are >= v1.0.0-rc93, <=1.1.11. For containerd the fixed versions are 1.6.28 and 1.7.13, the range of affected versions are 1.4.7 to 1.6.27 and 1.7.0 to 1.7.12. For Docker the fixed version is 25.0.2.
RepdoruceMy environment to repdouce it is:
Linux distro: Arch Linux Linux kernel: 6."><meta name=twitter:site content="@JayceCao"><meta name=application-name content="Nitro's Blog"><meta name=apple-mobile-web-app-title content="Nitro's Blog"><meta name=theme-color content="#f8f8f8"><link rel="shortcut icon" type=image/x-icon href=/favicon.ico><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=canonical href=https://nitroc.org/en/posts/cve-2024-21626-illustrated/><link rel=stylesheet href=/lib/normalize/normalize.min.css><link rel=stylesheet href=/css/style.min.css><link rel=preload as=style onload='this.onload=null,this.rel="stylesheet"' href=/lib/fontawesome-free/all.min.css><noscript><link rel=stylesheet href=/lib/fontawesome-free/all.min.css></noscript><link rel=preload as=style onload='this.onload=null,this.rel="stylesheet"' href=/lib/animate/animate.min.css><noscript><link rel=stylesheet href=/lib/animate/animate.min.css></noscript><script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","headline":"Illustrate runC Escape Vulnerability CVE-2024-21626","inLanguage":"en","mainEntityOfPage":{"@type":"WebPage","@id":"https:\/\/nitroc.org\/en\/posts\/cve-2024-21626-illustrated\/"},"genre":"posts","keywords":"CVE-2024-21626, runC","wordcount":1489,"url":"https:\/\/nitroc.org\/en\/posts\/cve-2024-21626-illustrated\/","datePublished":"2024-02-06T21:31:14+08:00","dateModified":"2024-02-16T17:22:10+08:00","publisher":{"@type":"Organization","name":"Nitro Cao"},"author":{"@type":"Person","name":"Nitro Cao"},"description":""}</script></head><body header-desktop=auto header-mobile=auto><script type=text/javascript>function setTheme(e){document.body.setAttribute("theme",e),document.documentElement.style.setProperty("color-scheme",e==="light"?"light":"dark")}function saveTheme(e){window.localStorage&&localStorage.setItem("theme",e)}function getMeta(e){const t=document.getElementsByTagName("meta");for(let n=0;n<t.length;n++)if(t[n].getAttribute("name")===e)return t[n];return""}if(window.localStorage&&localStorage.getItem("theme")){let e=localStorage.getItem("theme");e==="light"||e==="dark"||e==="black"?setTheme(e):setTheme(window.matchMedia&&window.matchMedia("(prefers-color-scheme: dark)").matches?"dark":"light")}else""==="light"||""==="dark"||""==="black"?(setTheme(""),saveTheme("")):(saveTheme("auto"),setTheme(window.matchMedia&&window.matchMedia("(prefers-color-scheme: dark)").matches?"dark":"light"));let metaColors={light:"#f8f8f8",dark:"#252627",black:"#000000"};getMeta("theme-color").content=metaColors[document.body.getAttribute("theme")]</script><div id=back-to-top></div><div id=mask></div><div class=wrapper><header class=desktop id=header-desktop><div class=header-wrapper><div class=header-title><a href=/en/ title="Nitro's Blog"><img class="lazyload logo" data-src=/logo.png data-srcset="/logo.png, /logo.png 1.5x, /logo.png 2x" data-sizes=auto alt=/logo.png title=/logo.png>Nitro's Blog</a></div><div class=menu><div class=menu-inner><a class=menu-item href=/en/posts/>Posts </a><a class=menu-item href=/en/tags/>Tags </a><a class=menu-item href=/en/categories/>Categories </a><span class="menu-item delimiter"></span><a href=# onclick=return!1 class="menu-item language" title="Select Language">English<i class="fas fa-chevron-right fa-fw"></i>
<select class=language-select title="Select Language" id=language-select-desktop onchange="location=this.value"><option value=/en/posts/cve-2024-21626-illustrated/ selected>English</option><option value=/posts/cve-2024-21626-illustrated/>简体中文</option></select>
</a><a href=# onclick=return!1 class="menu-item theme-switch" title="Switch Theme"><i class="fas fa-adjust fa-fw"></i></a></div></div></div></header><header class=mobile id=header-mobile><div class=header-container><div class=header-wrapper><div class=header-title><a href=/en/ title="Nitro's Blog"><img class="lazyload logo" data-src=/logo.png data-srcset="/logo.png, /logo.png 1.5x, /logo.png 2x" data-sizes=auto alt=/logo.png title=/logo.png>Nitro's Blog</a></div><div class=menu-toggle id=menu-toggle-mobile><span></span><span></span><span></span></div></div><div class=menu id=menu-mobile><a class=menu-item href=/en/posts/ title>Posts</a><a class=menu-item href=/en/tags/ title>Tags</a><a class=menu-item href=/en/categories/ title>Categories</a><a href=# onclick=return!1 class="menu-item theme-switch" title="Switch Theme">
<i class="fas fa-adjust fa-fw"></i>
</a><a href=# onclick=return!1 class=menu-item title="Select Language">English<i class="fas fa-chevron-right fa-fw"></i>
<select class=language-select title="Select Language" onchange="location=this.value"><option value=/en/posts/cve-2024-21626-illustrated/ selected>English</option><option value=/posts/cve-2024-21626-illustrated/>简体中文</option></select></a></div></div></header><div class="search-dropdown desktop"><div id=search-dropdown-desktop></div></div><div class="search-dropdown mobile"><div id=search-dropdown-mobile></div></div><main class=main><div class=container><div class=toc id=toc-auto><h2 class=toc-title>Contents</h2><div class="toc-content always-active" id=toc-content-auto><nav id=TableOfContents><ul><li><a href=#exploit-via-setting-working-directory-to-procselffdfd>Exploit via Setting Working Directory to /proc/self/fd/</a></li><li><a href=#exploit-via-docker-exec>Exploit via docker exec</a></li></ul><ul><li><ul><li><a href=#how-docker-engine-calls-runc>How Docker Engine Calls runC</a></li><li><a href=#reproduce-via-runc-itself>Reproduce via runC Itself</a></li><li><a href=#how-the-vulnerability-happens>How the Vulnerability Happens</a></li><li><a href=#why-runc-decides-to-use-openat22>Why runC Decides to Use openat2(2)</a></li><li><a href=#why-the-file-descriptor-of-sysfscgroup-is-7>Why the File Descriptor of /sys/fs/cgroup is 7</a></li><li><a href=#why-the-file-descriptor-of-sysfscgroup-is-8-when-running-a-container-with-docker-exec>Why the File Descriptor of /sys/fs/cgroup is 8 when Running a Container with docker exec</a></li><li><a href=#the-magic---log-parameter>The Magic --log Parameter</a></li><li><a href=#how-the-official-fixes-it>How the Official Fixes it</a></li></ul></li></ul><ul><li><a href=#leaky-vessels-dynamic-detector-from-synk>Leaky vessels dynamic detector from synk</a></li><li><a href=#falco>Falco</a></li></ul></nav></div></div><script>document.getElementsByTagName("main")[0].setAttribute("pageStyle","normal")</script><script>document.getElementsByTagName("main")[0].setAttribute("autoTOC","true")</script><article class="page single"><h1 class="single-title animate__animated animate__flipInX">Illustrate runC Escape Vulnerability CVE-2024-21626</h1><div class=post-meta><div class=post-meta-line><span class=post-author><i class="author fas fa-user-circle fa-fw"></i><a href=/en/ title=Author rel=author class=author>Nitro Cao</a>
</span>&nbsp;<span class=post-category>included in </span>&nbsp;<span class=post-category>category <a href=/en/categories/cloud-native-security/><i class="far fa-folder fa-fw"></i>Cloud Native Security</a></span></div><div class=post-meta-line><i class="far fa-calendar-alt fa-fw"></i>&nbsp;<time datetime=2024-02-06>2024-02-06</time>&nbsp;<i class="far fa-edit fa-fw"></i>&nbsp;<time datetime=2024-02-16>2024-02-16</time>&nbsp;<i class="fas fa-pencil-alt fa-fw"></i>&nbsp;1489 words&nbsp;
<i class="far fa-clock fa-fw"></i>&nbsp;7 minutes&nbsp;</div></div><div class="details toc" id=toc-static kept><div class="details-summary toc-title"><span>Contents</span>
<span><i class="details-icon fas fa-angle-right"></i></span></div><div class="details-content toc-content" id=toc-content-static><nav id=TableOfContents><ul><li><a href=#exploit-via-setting-working-directory-to-procselffdfd>Exploit via Setting Working Directory to /proc/self/fd/</a></li><li><a href=#exploit-via-docker-exec>Exploit via docker exec</a></li></ul><ul><li><ul><li><a href=#how-docker-engine-calls-runc>How Docker Engine Calls runC</a></li><li><a href=#reproduce-via-runc-itself>Reproduce via runC Itself</a></li><li><a href=#how-the-vulnerability-happens>How the Vulnerability Happens</a></li><li><a href=#why-runc-decides-to-use-openat22>Why runC Decides to Use openat2(2)</a></li><li><a href=#why-the-file-descriptor-of-sysfscgroup-is-7>Why the File Descriptor of /sys/fs/cgroup is 7</a></li><li><a href=#why-the-file-descriptor-of-sysfscgroup-is-8-when-running-a-container-with-docker-exec>Why the File Descriptor of /sys/fs/cgroup is 8 when Running a Container with docker exec</a></li><li><a href=#the-magic---log-parameter>The Magic --log Parameter</a></li><li><a href=#how-the-official-fixes-it>How the Official Fixes it</a></li></ul></li></ul><ul><li><a href=#leaky-vessels-dynamic-detector-from-synk>Leaky vessels dynamic detector from synk</a></li><li><a href=#falco>Falco</a></li></ul></nav></div></div><div class=content id=content><p>runC, a container runtime component, published version <code>1.1.12</code> to fix <strong>CVE-2024-21626</strong> at 31, Jan 2024, which leads to escaping from containers. The range of affected versions are <strong>>= v1.0.0-rc93, &lt;=1.1.11</strong>. For containerd the fixed versions are <strong>1.6.28</strong> and <strong>1.7.13</strong>, the range of affected versions are <strong>1.4.7</strong> to <strong>1.6.27</strong> and <strong>1.7.0</strong> to <strong>1.7.12</strong>. For Docker the fixed version is <strong>25.0.2</strong>.</p><h1 id=repdoruce class=headerLink><a href=#repdoruce class=header-mark></a>Repdoruce</h1><p>My environment to repdouce it is:</p><ul><li>Linux distro: Arch Linux</li><li>Linux kernel: 6.4.12-arch1-1</li><li>Docker version: 24.0.6</li><li>runc version: 1.1.9</li></ul><p>According to the root cause of the vulnerability, attackers can exploit via two different ways:</p><ul><li>Set the working directory of the container to <code>/proc/self/fd/&lt;fd></code> (where <code>&lt;fd></code> stands for the file descriptor when opening <code>/sys/fs/cgroup</code> in host filesystem. Usually it&rsquo;s 7 or 8) when running a container.</li><li>Create a symlink for <code>/proc/self/fd/&lt;fd></code> (where <code>&lt;fd></code> stands for the file descriptor when opening <code>/sys/fs/cgroup</code> in host filesystem. Usually it&rsquo;s 7 or 8). When users execute commands inside the container via <code>docker exec</code> or <code>kubectl exec</code> by setting the working directory to the symlink, attackers can access host filesystem through <code>/proc/&lt;PID>/cwd</code>, where <code>&lt;PID></code> stands for the PID of the process generated by <code>docker exec</code> or <code>kubectl exec</code> command.</li></ul><h2 id=exploit-via-setting-working-directory-to-procselffdfd class=headerLink><a href=#exploit-via-setting-working-directory-to-procselffdfd class=header-mark></a>Exploit via Setting Working Directory to /proc/self/fd/</h2><p>Just run the following command:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>docker run -w /proc/self/fd/8 --name cve-2024-21626 --rm -it debian:bookworm
</span></span></code></pre></div><p><img class=lazyload data-src=/images/cve-2024-21626-escape-via-crafted-image.gif data-srcset="/images/cve-2024-21626-escape-via-crafted-image.gif, /images/cve-2024-21626-escape-via-crafted-image.gif 1.5x, /images/cve-2024-21626-escape-via-crafted-image.gif 2x" data-sizes=auto alt=/images/cve-2024-21626-escape-via-crafted-image.gif title="exploit via setting working directory to /proc/self/fd/<!-- raw HTML omitted -->"></p><h2 id=exploit-via-docker-exec class=headerLink><a href=#exploit-via-docker-exec class=header-mark></a>Exploit via docker exec</h2><p>Start a container and create a symlink for <code>/proc/self/fd/8</code>.</p><p>Execute <code>docker exec</code> command with <code>-w</code> parameter to execute <code>sleep</code> command in the container.</p><p>Inside the container, find PID of <code>sleep</code> command, then access host filesystem via <code>/proc/&lt;PID>/cwd</code>. For example, execute <code>cat /proc/&lt;PID>/cwd/../../../../../etc/shadow</code> to get shadow file in host filesystem.</p><p><img class=lazyload data-src=/images/cve-2024-21626-escape-via-exec.gif data-srcset="/images/cve-2024-21626-escape-via-exec.gif, /images/cve-2024-21626-escape-via-exec.gif 1.5x, /images/cve-2024-21626-escape-via-exec.gif 2x" data-sizes=auto alt=/images/cve-2024-21626-escape-via-exec.gif title="exploit via docker exec"></p><h1 id=analyze-cve-2024-21626 class=headerLink><a href=#analyze-cve-2024-21626 class=header-mark></a>Analyze CVE-2024-21626</h1><p>In this section, I&rsquo;ll describe the calling relationship among the components at first. Then reproduce the vulnerability again with <code>runc run</code> command, and explain how the vulnerability happens. Lastly analyze the code to fix the vulnerability.</p><h3 id=how-docker-engine-calls-runc class=headerLink><a href=#how-docker-engine-calls-runc class=header-mark></a>How Docker Engine Calls runC</h3><p>When running a container with <code>docker run</code> command, the calling relationship among <code>dockerd</code>, <code>containerd</code>, <code>containerd-shim-runc-v2</code> and <code>runc</code> is:</p><div class=mermaid id=id-1></div><ul><li>Docker Engine (dockerd) calls RPC methods of containerd to create and run a container via <code>/run/containerd/containerd.sock</code>.</li><li>containerd executes <code>containerd-shim-runc-v2</code> command to run a standalone RPC service via UNIX domain socket, the path of which is stored in file <code>/run/containerd/io.containerd.v2.task/moby/&lt;containerID>/address</code> by default. The definition of the RPC service lies on file <a href=https://github.com/containerd/containerd/blob/96bf529cbf55940ddb96bb8adc8be51b11922ebb/api/runtime/task/v3/shim.proto target=_blank rel="noopener noreffer"><code>/api/runtime/task/v3/shim.proto</code></a>.</li><li>When containerd calls <a href rel><code>Create</code></a> method of containerd-shim-runc-v2 to create a container, containerd-shim-runc-v2 executes <code>runc create</code> command. When containerd calls <a href rel><code>Start</code></a> method of containerd-shim-runc-v2 to start a container, containerd-shim-runc-v2 executes <code>runc start</code> command.</li></ul><p>By the way, containerd creates a package called <code>github.com/containerd/go-runc</code> to encapsulate operations of runC.</p><h3 id=reproduce-via-runc-itself class=headerLink><a href=#reproduce-via-runc-itself class=header-mark></a>Reproduce via runC Itself</h3><p>Use Docker to run a container with alpine image, then export it as a tar archive. We&rsquo;ll use it as rootfs of our container later.</p><p>Execute <code>runc spec</code> command to generate a default config file <code>config.json</code>, and change the value of key <code>cwd</code> to <code>/proc/self/fd/7</code>.</p><p>Run a container by executing <code>runc run</code> command to create a exploitable container. <strong>Note that <code>--log</code> parameter is necessary!</strong></p><p><img class=lazyload data-src=/images/cve-2024-21626-reproduce-via-runc.gif data-srcset="/images/cve-2024-21626-reproduce-via-runc.gif, /images/cve-2024-21626-reproduce-via-runc.gif 1.5x, /images/cve-2024-21626-reproduce-via-runc.gif 2x" data-sizes=auto alt=/images/cve-2024-21626-reproduce-via-runc.gif title="exploit via runc itself"></p><h3 id=how-the-vulnerability-happens class=headerLink><a href=#how-the-vulnerability-happens class=header-mark></a>How the Vulnerability Happens</h3><div class=mermaid id=id-2></div><p><code>runc run</code> command <a href=https://github.com/opencontainers/runc/blob/4bccb38cc9cf198d52bebf2b3a90cd14e7af8c06/utils_linux.go#L195 target=_blank rel="noopener noreffer">creates a <code>libcontainer.linuxContainer</code> object at first</a>. In order to create the object, runC needs to <a href=https://github.com/opencontainers/runc/blob/4bccb38cc9cf198d52bebf2b3a90cd14e7af8c06/libcontainer/factory_linux.go#L147 target=_blank rel="noopener noreffer">create an interface object called <code>cgroups.Manager</code></a>, which is used to manage cgroupfs. It&rsquo;ll <a href=https://github.com/opencontainers/runc/blob/4bccb38cc9cf198d52bebf2b3a90cd14e7af8c06/libcontainer/cgroups/file.go#L86 target=_blank rel="noopener noreffer">open <code>/sys/fs/cgroup</code> in host filesystem</a>, and <a href=https://github.com/opencontainers/runc/blob/4bccb38cc9cf198d52bebf2b3a90cd14e7af8c06/libcontainer/cgroups/file.go#L119 target=_blank rel="noopener noreffer">subsequent operations to cgroup files are based on <code>openat2(2)</code> system call and the file descriptor of <code>/sys/fs/cgroup</code></a>. But runC donesn&rsquo;t close the file descriptor of <code>/sys/fs/cgroup</code> in time when forking child processes, so that child processes can access host filesystem through <code>/proc/self/fd/&lt;fdnum></code>.</p><p>Notice that if calling <code>openat2(2)</code> system call failed (if <code>openat2(2)</code> doesn&rsquo;t exist), runC will call function <code>openFallback()</code> to open cgroup files with absolute paths.</p><h3 id=why-runc-decides-to-use-openat22 class=headerLink><a href=#why-runc-decides-to-use-openat22 class=header-mark></a>Why runC Decides to Use openat2(2)</h3><p><a href=https://github.com/opencontainers/runc/commit/6bda4600003e145f5aff4dd8d9d2d5866fc44ce9 target=_blank rel="noopener noreffer">runC added support to <code>openat2(2)</code> in 4, Dec 2024, aka version <code>v1.0.0-rc93</code></a>. The answer, in brief, is to prevent potential security risks when mounting directories in host filesystem into mount namespace of containers. It&rsquo;s a long story to give a detailed explanation, and deserved to write another article. For now you can refer to <a href=https://people.kernel.org/brauner/mounting-into-mount-namespaces target=_blank rel="noopener noreffer">this article</a> and manual of <code>openat2(2)</code>.</p><h3 id=why-the-file-descriptor-of-sysfscgroup-is-7 class=headerLink><a href=#why-the-file-descriptor-of-sysfscgroup-is-7 class=header-mark></a>Why the File Descriptor of /sys/fs/cgroup is 7</h3><p>Well, it&rsquo;s related to Golang runtime. First there is no doubt that file descriptor 0, 1 and 2 are stands for stdin, stdout, stderr. The file descriptor of the log file specified by <code>--log</code> parameter is 3. Golang runtime subsequently calls <code>epoll_create(2)</code> to create file descriptor 4 and <code>pipe(2)</code> to create two file descriptors 5 and 6. Now, opening <code>/sys/fs/cgroup</code> creates file descriptor 7.</p><blockquote><p>The reason why opening the log file at first, then Go runtime calling <code>epoll_create(2)</code> and <code>pipe2(2)</code> is related to the implementation of Go runtime, it&rsquo;s a long story again.</p></blockquote><h3 id=why-the-file-descriptor-of-sysfscgroup-is-8-when-running-a-container-with-docker-exec class=headerLink><a href=#why-the-file-descriptor-of-sysfscgroup-is-8-when-running-a-container-with-docker-exec class=header-mark></a>Why the File Descriptor of /sys/fs/cgroup is 8 when Running a Container with docker exec</h3><p>From the first part of this section, we know that it&rsquo;s containerd-shim-runc-v2 that calls runc command, and containerd-shim-runc-v2 provides a RPC service via UNIX domain socket before executing runC, so the file descriptor which stands for the UNIX domain socket is passed to runC process by mistake.</p><p>We can prove the reason in this way. Add a new line to call <code>sleep()</code> function at the very beginning of <code>nsexec()</code> function in file <code>nsexec.c</code>. We can get the relationship of file descriptors between containerd-shim-runc-v2 and <code>runc create</code>.</p><p><img class=lazyload data-src=/images/rpc-socket-passed-to-runc.png data-srcset="/images/rpc-socket-passed-to-runc.png, /images/rpc-socket-passed-to-runc.png 1.5x, /images/rpc-socket-passed-to-runc.png 2x" data-sizes=auto alt=/images/rpc-socket-passed-to-runc.png title="the UNIX socket that stands for the UNIX socket is passed to runC process by mistake"></p><p>Process <code>runc create</code> is blocked immediately after it&rsquo;s been created because of our added sleep function. From the screenshot above Process <code>runc create</code> has 4 file descriptors:</p><ul><li>0 stands for stdin. It&rsquo;s been redirected to /dev/null because containerd-shim-runc-v2 don&rsquo;t need to send any input data to runC.</li><li>1 and 2 stands for stdout and stderr. They refer to the same pipe from containerd-shim-runc-v2, because containerd-shim-runc-v2 wants to collect and store them.</li><li>3 stands for the UNIX domain socket used to be provide the RPC service.</li></ul><p><img class=lazyload data-src=/images/sys-fs-cgroup-with-fd-8.png data-srcset="/images/sys-fs-cgroup-with-fd-8.png, /images/sys-fs-cgroup-with-fd-8.png 1.5x, /images/sys-fs-cgroup-with-fd-8.png 2x" data-sizes=auto alt=/images/sys-fs-cgroup-with-fd-8.png title="the fd of /sys/fs/cgroup in /proc/self/exe init process"></p><p>PID 1374988 in the screenshot above stands for <code>runc:[2:INIT]</code> process, which in turn will become the container process after calling <code>execve(2)</code>. We can see that the fd of <code>/sys/fs/cgroup</code> is 8, just beucase of the UNIX domain socket offering RPC service!</p><blockquote><p>It&rsquo;s still unclear why sometimes the fd of /sys/fs/cgroup is still 7 when running containers via <code>docker exec</code>. Guess that it&rsquo;s still related to Go runtime.</p></blockquote><h3 id=the-magic---log-parameter class=headerLink><a href=#the-magic---log-parameter class=header-mark></a>The Magic --log Parameter</h3><p>when reproducing the vulnerability via runC itself, if we didn&rsquo;t specify <code>--log</code> parameter, the fd of /sys/fs/cgroup would become 3, thus the exploit would not happen, cause Go runtime would close it. The reason is related to the implementation of Go runtime.</p><p>As we all know, we use <code>fork(2)</code> to create a child process on Linux, and the child process will inherit all opened file descriptors from the parent process. But when executing a new program by using <code>execve(2)</code>, Linux kernel will close those file descriptors which have <code>O_CLOEXEC</code> flag set. But the remaining opened file descriptors are still accessible for the newly loaded program. In this case, it may lead to potential security risk.</p><p><a href=https://github.com/golang/go/blob/26b5783b72376acd0386f78295e678b9a6bff30e/src/syscall/exec_unix.go#L22-L64 target=_blank rel="noopener noreffer">In order to solve the problem, the design of Golang is to prevent child processes from inheriting all file descriptors by default</a>. Developers need to pass those file descriptors to be inherited explicitly. Specifically, Golang runtime sets <code>O_CLOEXEC</code> flag for each file descriptor. For those to be inherited, Golang runtime uses <code>dup3(2)</code> to duplicate new file descriptors. <strong>Be notice that those file descriptors created by calling raw syscalls don&rsquo;t be flagged as <code>O_CLOEXEC</code> by default, so for these file descriptors whether they can be inherited by child processes depends on the actual situation</strong>. If the value of file descriptor is greater than <code>len(Cmd.ExtraFiles) + 3</code>, it can be inherited successfully. Otherwise it&rsquo;ll be closed. <a href=https://github.com/golang/go/blob/26b5783b72376acd0386f78295e678b9a6bff30e/src/syscall/exec_linux.go#L554-L597 target=_blank rel="noopener noreffer">You can read the source code of Golang to get more detail</a>.</p><h3 id=how-the-official-fixes-it class=headerLink><a href=#how-the-official-fixes-it class=header-mark></a>How the Official Fixes it</h3><p>We see four commits to fix the vulnerability in the repo, <a href=https://github.com/opencontainers/runc/commit/8e1cd2f56d518f8d6292b8bb39f0d0932e4b6c2a target=_blank rel="noopener noreffer">8e1cd2</a>、<a href=https://github.com/opencontainers/runc/commit/f2f16213e174fb63e931fe0546bbbad1d9bbed6f target=_blank rel="noopener noreffer">f2f162</a>、<a href=https://github.com/opencontainers/runc/commit/89c93ddf289437d5c8558b37047c54af6a0edb48 target=_blank rel="noopener noreffer">89c93d</a>、<a href=https://github.com/opencontainers/runc/commit/ee73091a8d28692fa4868bac81aa40a0b05f9780 target=_blank rel="noopener noreffer">ee7309</a>. The last three commits aims to close unnecessary file descriptors before forking children. The first commit aims to verify whether the current working directory is inside container or not.</p><h1 id=how-to-detect class=headerLink><a href=#how-to-detect class=header-mark></a>How to detect</h1><p>The exploits have the following characteristics:</p><ul><li>A container will <code>execve(2)</code> a process with a special working directory which starts with <code>/proc/self/fd/</code>.</li><li>A container will create symbolic links via <code>symlink(2)</code> or <code>symlinkat(2)</code> with a special target directory link which starts with <code>/proc/self/fd/</code>.</li><li>A container will open files via <code>open(2)</code>, <code>openat(2)</code> or <code>openat2(2)</code> with filenames like <code>/proc/\d+/cwd/.*</code>.</li></ul><h2 id=leaky-vessels-dynamic-detector-from-synk class=headerLink><a href=#leaky-vessels-dynamic-detector-from-synk class=header-mark></a>Leaky vessels dynamic detector from synk</h2><p>Synk <a href=https://github.com/snyk/leaky-vessels-dynamic-detector target=_blank rel="noopener noreffer">offers a tool to detect this vulnerability</a>. It&rsquo;s implemented by using eBPF, but eBPF code is not open-source. I&rsquo;ll write a article later to RE it.</p><h2 id=falco class=headerLink><a href=#falco class=header-mark></a>Falco</h2><p>Here is the custom Falco rule:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-yaml data-lang=yaml><span class=line><span class=cl>- <span class=nt>macro</span><span class=p>:</span><span class=w> </span><span class=l>container</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>condition</span><span class=p>:</span><span class=w> </span><span class=l>(container.id != host and container.name exists)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span>- <span class=nt>rule</span><span class=p>:</span><span class=w> </span><span class=l>CVE-2024-21626 (runC escape through /proc/[PID]/cwd) exploited</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>desc</span><span class=p>:</span><span class=w> </span><span class=p>&gt;</span><span class=sd>
</span></span></span><span class=line><span class=cl><span class=sd>    Detect CVE-2024-21626, runC escape vulerability through /proc/[PID]/cwd.</span><span class=w>    
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>condition</span><span class=p>:</span><span class=w> </span><span class=p>&gt;</span><span class=sd>
</span></span></span><span class=line><span class=cl><span class=sd>    container and ((evt.type = execve and proc.cwd startswith &#34;/proc/self/fd&#34;) or (evt.type in (open, openat, openat2) and fd.name glob &#34;/proc/*/cwd/*&#34;) or (evt.type in (symlink, symlinkat) and fs.path.target startswith &#34;/proc/self/fd/&#34;)) and proc.name != &#34;runc:[1:CHILD]&#34;</span><span class=w>    
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>output</span><span class=p>:</span><span class=w> </span><span class=l>CVE-2024-21626 exploited (%container.info evt_type=%evt.type process=%proc.name command=%proc.cmdline target=%fs.path.targetraw)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>priority</span><span class=p>:</span><span class=w> </span><span class=l>CRITICAL</span><span class=w>
</span></span></span></code></pre></div><p>But filtering false positives with <code>proc.name</code> is not a good idea.</p><p><img class=lazyload data-src=/images/cve-2024-21626-detect-via-falco.gif data-srcset="/images/cve-2024-21626-detect-via-falco.gif, /images/cve-2024-21626-detect-via-falco.gif 1.5x, /images/cve-2024-21626-detect-via-falco.gif 2x" data-sizes=auto alt=/images/cve-2024-21626-detect-via-falco.gif title="detect exploits with Falco"></p><h1 id=references class=headerLink><a href=#references class=header-mark></a>References</h1><ul><li><p><a href=https://github.com/opencontainers/runc/security/advisories/GHSA-xr7r-f8xq-vfvv target=_blank rel="noopener noreffer">https://github.com/opencontainers/runc/security/advisories/GHSA-xr7r-f8xq-vfvv</a></p></li><li><p><a href=https://github.com/opencontainers/runc/commit/8e1cd2f56d518f8d6292b8bb39f0d0932e4b6c2a target=_blank rel="noopener noreffer">https://github.com/opencontainers/runc/commit/8e1cd2f56d518f8d6292b8bb39f0d0932e4b6c2a</a></p></li><li><p><a href=https://github.com/opencontainers/runc/commit/f2f16213e174fb63e931fe0546bbbad1d9bbed6f target=_blank rel="noopener noreffer">https://github.com/opencontainers/runc/commit/f2f16213e174fb63e931fe0546bbbad1d9bbed6f</a></p></li><li><p><a href=https://github.com/opencontainers/runc/commit/89c93ddf289437d5c8558b37047c54af6a0edb48 target=_blank rel="noopener noreffer">https://github.com/opencontainers/runc/commit/89c93ddf289437d5c8558b37047c54af6a0edb48</a></p></li><li><p><a href=https://github.com/opencontainers/runc/commit/ee73091a8d28692fa4868bac81aa40a0b05f9780 target=_blank rel="noopener noreffer">https://github.com/opencontainers/runc/commit/ee73091a8d28692fa4868bac81aa40a0b05f9780</a></p></li><li><p><a href=https://access.redhat.com/security/cve/cve-2024-21626 target=_blank rel="noopener noreffer">https://access.redhat.com/security/cve/cve-2024-21626</a></p></li><li><p><a href=https://github.com/snyk/leaky-vessels-dynamic-detector target=_blank rel="noopener noreffer">https://github.com/snyk/leaky-vessels-dynamic-detector</a></p></li><li><p><a href=https://snyk.io/blog/cve-2024-21626-runc-process-cwd-container-breakout/ target=_blank rel="noopener noreffer">https://snyk.io/blog/cve-2024-21626-runc-process-cwd-container-breakout/</a></p></li><li><p><a href=https://nvd.nist.gov/vuln/detail/CVE-2024-21626 target=_blank rel="noopener noreffer">https://nvd.nist.gov/vuln/detail/CVE-2024-21626</a></p></li><li><p><a href=https://github.com/snyk/leaky-vessels-dynamic-detector target=_blank rel="noopener noreffer">https://github.com/snyk/leaky-vessels-dynamic-detector</a></p></li><li><p><a href=https://man7.org/linux/man-pages/man2/openat2.2.html target=_blank rel="noopener noreffer">https://man7.org/linux/man-pages/man2/openat2.2.html</a></p></li><li><p><a href=https://lkml.kernel.org/linux-fsdevel/20191026185700.10708-1-cyphar@cyphar.com/ target=_blank rel="noopener noreffer">https://lkml.kernel.org/linux-fsdevel/20191026185700.10708-1-cyphar@cyphar.com/</a></p></li></ul></div><div class=post-footer id=post-footer><div class=post-info><div class=post-info-line><div class=post-info-mod><span>Updated on 2024-02-16</span></div><div class=post-info-license></div></div><div class=post-info-line><div class=post-info-md></div><div class=post-info-share><span></span></div></div></div><div class=post-info-more><section class=post-tags><i class="fas fa-tags fa-fw"></i>&nbsp;<a href=/en/tags/cve-2024-21626/>CVE-2024-21626</a>,&nbsp;<a href=/en/tags/runc/>runC</a></section><section><span><a href=javascript:void(0); onclick=window.history.back()>Back</a></span>&nbsp;|&nbsp;<span><a href=/en/>Home</a></span></section></div><div class=post-nav></div></div><div id=comments><div id=gitalk class=comment></div><noscript>Please enable JavaScript to view the comments powered by <a href=https://github.com/gitalk/gitalk></a>Gitalk</a>.</noscript></div></article></div></main><footer class=footer><div class=footer-container><div class=footer-line>由 Hugo 强力驱动</div><div class=footer-line>Powered by <a href=https://gohugo.io/ target=_blank rel="noopener noreffer" title="Hugo 0.122.0">Hugo</a>&nbsp;|&nbsp;Theme - <a href=https://github.com/HEIGE-PCloud/DoIt target=_blank rel="noopener noreffer" title="DoIt 0.2.13"><i class="far fa-edit fa-fw"></i> DoIt</a></div><div class=footer-line><i class="far fa-copyright fa-fw"></i><span itemprop=copyrightYear>2022 - 2024</span><span class=author itemprop=copyrightHolder>&nbsp;<a href=/en/ target=_blank rel="noopener noreferrer"></a></span>&nbsp;|&nbsp;<span class=license><a rel="license external nofollow noopener noreffer" href=https://creativecommons.org/licenses/by-nc/4.0/ target=_blank>CC BY-NC 4.0</a></span></div><div class=footer-line></div><div class=footer-line></div></div></footer></div><div id=fixed-buttons><a href=#back-to-top id=back-to-top-button class=fixed-button title="Back to Top"><i class="fas fa-arrow-up fa-fw"></i>
</a><a href=# id=view-comments class=fixed-button title="View Comments"><i class="fas fa-comment fa-fw"></i></a></div><div class=assets><script type=text/javascript src=/lib/lazysizes/lazysizes.min.js></script><script type=text/javascript src=/lib/topbar/topbar.min.js></script><script type=text/javascript src=/lib/pjax/pjax.min.js></script><script type=text/javascript src=/js/theme.min.js defer></script></div><div class=pjax-assets><script type=text/javascript>window.config={code:{copyTitle:"Copy to clipboard",maxShownLines:50},comment:{gitalk:{admin:["NitroCao"],clientID:"94646e9139c4cfbac497",clientSecret:"0fda151ceb53b61ce441679301c2e558c2ffb86b",id:"2024-02-06T21:31:14+08:00",owner:"NitroCao",repo:"nitrocao.github.io",title:"Illustrate runC Escape Vulnerability CVE-2024-21626"}},data:{"id-1":`graph
dockerd-. "/run/containerd/containerd.sock" .->containerd-- "fork(2) & execve(2)" -->containerd-shim-runc-v2-- "fork(2) & execve(2)" -->runc`,"id-2":`graph
startContainer-->createContainer-.->B["(*linuxFactory).Create"]-.->C["(*manager).GetFreezerState"]-.->D["cgroups.prepareOpenat2"]-.if openat2 syscall failed.->E["openFallback"]`},mermaid:!0}</script><script type=text/javascript src=/lib/gitalk/gitalk.min.js></script><script type=text/javascript src=/js/gitalk.min.js defer></script><script type=text/javascript src=/lib/clipboard/clipboard.min.js></script><script type=text/javascript src=/lib/mermaid/mermaid.min.js defer></script><script type=text/javascript src=/js/mermaid.min.js defer></script><link rel=stylesheet href=/lib/gitalk/gitalk.min.css><link rel=stylesheet href=/lib/mermaid/mermaid.min.css></div></body></html>