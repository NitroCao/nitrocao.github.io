<!doctype html><html lang=cn><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=robots content="noodp"><title class=pjax-title>spec 子命令的实现 - Nitro's Blog</title><meta name=Description content="Nitro's Blog"><meta property="og:title" content="spec 子命令的实现"><meta property="og:description" content="本篇文章介绍 OCI 标准以及 runC 的 spec 子命令的实现。只关注 Linux 平台的实现。"><meta property="og:type" content="article"><meta property="og:url" content="https://nitroc.org/posts/read-source-code-of-runc-spec-subcommand/"><meta property="og:image" content="https://nitroc.org/logo.png"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-05-18T21:18:12+08:00"><meta property="article:modified_time" content="2022-05-18T21:18:12+08:00"><meta property="og:site_name" content="Nitro's Blog"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://nitroc.org/logo.png"><meta name=twitter:title content="spec 子命令的实现"><meta name=twitter:description content="本篇文章介绍 OCI 标准以及 runC 的 spec 子命令的实现。只关注 Linux 平台的实现。"><meta name=application-name content="Nitro's Blog"><meta name=apple-mobile-web-app-title content="Nitro's Blog"><meta name=theme-color content="#f8f8f8"><link rel="shortcut icon" type=image/x-icon href=/favicon.ico><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=canonical href=https://nitroc.org/posts/read-source-code-of-runc-spec-subcommand/><link rel=prev href=https://nitroc.org/posts/read-source-code-of-runc-prepare-environment/><link rel=stylesheet href=/lib/normalize/normalize.min.css><link rel=stylesheet href=/css/style.min.css><link rel=preload as=style onload='this.onload=null,this.rel="stylesheet"' href=/lib/fontawesome-free/all.min.css><noscript><link rel=stylesheet href=/lib/fontawesome-free/all.min.css></noscript><link rel=preload as=style onload='this.onload=null,this.rel="stylesheet"' href=/lib/animate/animate.min.css><noscript><link rel=stylesheet href=/lib/animate/animate.min.css></noscript><script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","headline":"spec 子命令的实现","inLanguage":"cn","mainEntityOfPage":{"@type":"WebPage","@id":"https:\/\/nitroc.org\/posts\/read-source-code-of-runc-spec-subcommand\/"},"genre":"posts","keywords":"Linux, Container, Cloud Native","wordcount":229,"url":"https:\/\/nitroc.org\/posts\/read-source-code-of-runc-spec-subcommand\/","datePublished":"2022-05-18T21:18:12+08:00","dateModified":"2022-05-18T21:18:12+08:00","publisher":{"@type":"Organization","name":"Nitro Cao"},"author":{"@type":"Person","name":"Nitro Cao"},"description":""}</script></head><body header-desktop=auto header-mobile=auto><script type=text/javascript>function setTheme(e){document.body.setAttribute("theme",e),document.documentElement.style.setProperty("color-scheme",e==="light"?"light":"dark")}function saveTheme(e){window.localStorage&&localStorage.setItem("theme",e)}function getMeta(t){const e=document.getElementsByTagName("meta");for(let n=0;n<e.length;n++)if(e[n].getAttribute("name")===t)return e[n];return''}if(window.localStorage&&localStorage.getItem("theme")){let e=localStorage.getItem("theme");e==="light"||e==="dark"||e==="black"?setTheme(e):window.matchMedia&&window.matchMedia("(prefers-color-scheme: dark)").matches?setTheme("dark"):setTheme("light")}else''==="light"||''==="dark"||''==="black"?(setTheme(''),saveTheme('')):(saveTheme("auto"),window.matchMedia&&window.matchMedia("(prefers-color-scheme: dark)").matches?setTheme("dark"):setTheme("light"));let metaColors={light:"#f8f8f8",dark:"#252627",black:"#000000"};getMeta("theme-color").content=metaColors[document.body.getAttribute("theme")]</script><div id=back-to-top></div><div id=mask></div><div class=wrapper><header class=desktop id=header-desktop><div class=header-wrapper><div class=header-title><a href=/ title="Nitro's Blog"><img class="lazyload logo" data-src=/logo.png data-srcset="/logo.png, /logo.png 1.5x, /logo.png 2x" data-sizes=auto alt=/logo.png title=/logo.png>Nitro's Blog</a></div><div class=menu><div class=menu-inner><a class=menu-item href=/posts/>Posts </a><a class=menu-item href=/tags/>Tags </a><a class=menu-item href=/categories/>Categories </a><a class=menu-item href=/series/>Series </a><span class="menu-item delimiter"></span><a href=# onclick=return!1 class="menu-item theme-switch" title>
<i class="fas fa-adjust fa-fw"></i></a></div></div></div></header><header class=mobile id=header-mobile><div class=header-container><div class=header-wrapper><div class=header-title><a href=/ title="Nitro's Blog"><img class="lazyload logo" data-src=/logo.png data-srcset="/logo.png, /logo.png 1.5x, /logo.png 2x" data-sizes=auto alt=/logo.png title=/logo.png>Nitro's Blog</a></div><div class=menu-toggle id=menu-toggle-mobile><span></span><span></span><span></span></div></div><div class=menu id=menu-mobile><a class=menu-item href=/posts/ title>Posts</a><a class=menu-item href=/tags/ title>Tags</a><a class=menu-item href=/categories/ title>Categories</a><a class=menu-item href=/series/ title>Series</a><a href=# onclick=return!1 class="menu-item theme-switch" title>
<i class="fas fa-adjust fa-fw"></i></a></div></div></header><div class="search-dropdown desktop"><div id=search-dropdown-desktop></div></div><div class="search-dropdown mobile"><div id=search-dropdown-mobile></div></div><main class=main><div class=container><div class=toc id=toc-auto><h2 class=toc-title></h2><div class="toc-content always-active" id=toc-content-auto><nav id=TableOfContents><ul><li><a href=#什么是-oci-spec>什么是 OCI Spec</a><ul><li><a href=#runtime-spec>runtime spec</a></li></ul></li><li><a href=#创建-runtime-spec>创建 runtime spec</a></li><li><a href=#spec-子命令的具体实现>spec 子命令的具体实现</a><ul><li><a href=#runc-的运行时目录>runC 的运行时目录</a></li><li><a href=#容器的格式>容器的格式</a></li><li><a href=#用来描述-runtime-spec-的结构体-specsspec>用来描述 runtime spec 的结构体 specs.Spec</a></li><li><a href=#runc-的默认-runtime-spec>runC 的默认 runtime spec</a></li></ul></li></ul></nav></div></div><script>document.getElementsByTagName("main")[0].setAttribute("pageStyle","normal")</script><script>document.getElementsByTagName("main")[0].setAttribute("autoTOC","true")</script><article class="page single"><h1 class="single-title animate__animated animate__flipInX">spec 子命令的实现</h1><div class=post-meta><div class=post-meta-line><span class=post-author><i class="author fas fa-user-circle fa-fw"></i><a href=/ title=Author rel=author class=author>Nitro Cao</a>
</span>&nbsp;<span class=post-category></span>&nbsp;<span class=post-category></span>&nbsp;<span class=post-category></span>&nbsp;<span class=post-series></span></div><div class=post-meta-line><i class="far fa-calendar-alt fa-fw"></i>&nbsp;<time datetime=2022-05-18>2022-05-18</time>&nbsp;<i class="far fa-edit fa-fw"></i>&nbsp;<time datetime=2022-05-18>2022-05-18</time>&nbsp;<i class="fas fa-pencil-alt fa-fw"></i>&nbsp;&nbsp;
<i class="far fa-clock fa-fw"></i>&nbsp;&nbsp;</div></div><div class="details series-nav open"><div class="details-summary series-title"><span>- runC 源码分析</span>
<span><i class="details-icon fas fa-angle-right"></i></span></div><div class="details-content series-content"><nav><ul><li><span class=active>spec 子命令的实现</span></li><li><a href=/posts/read-source-code-of-runc-prepare-environment/>准备 runC 源码环境</a></li></ul></nav></div></div><div class="details toc" id=toc-static kept><div class="details-summary toc-title"><span></span>
<span><i class="details-icon fas fa-angle-right"></i></span></div><div class="details-content toc-content" id=toc-content-static><nav id=TableOfContents><ul><li><a href=#什么是-oci-spec>什么是 OCI Spec</a><ul><li><a href=#runtime-spec>runtime spec</a></li></ul></li><li><a href=#创建-runtime-spec>创建 runtime spec</a></li><li><a href=#spec-子命令的具体实现>spec 子命令的具体实现</a><ul><li><a href=#runc-的运行时目录>runC 的运行时目录</a></li><li><a href=#容器的格式>容器的格式</a></li><li><a href=#用来描述-runtime-spec-的结构体-specsspec>用来描述 runtime spec 的结构体 specs.Spec</a></li><li><a href=#runc-的默认-runtime-spec>runC 的默认 runtime spec</a></li></ul></li></ul></nav></div></div><div class=content id=content><p>本篇文章介绍 OCI 标准以及 runC 的 <code>spec</code> 子命令的实现。只关注 Linux 平台的实现。</p><h2 id=什么是-oci-spec class=headerLink><a href=#%e4%bb%80%e4%b9%88%e6%98%af-oci-spec class=header-mark></a>什么是 OCI Spec</h2><p>OCI（Open Container Initiative）是一个在 Linux 基金会主导下成立的开源组织，目的是围绕容器格式和运行时制定开放的行业标准。</p><p>OCI 目前包括两个标准：<strong>运行时标准</strong>（Runtime Specification，runtime-spec）<sup id=fnref:1><a href=#fn:1 class=footnote-ref role=doc-noteref>1</a></sup>和<strong>镜像标准</strong>（Image Specification，image-spec）<sup id=fnref:2><a href=#fn:2 class=footnote-ref role=doc-noteref>2</a></sup>。前者规定了如何从硬盘上的一个文件系统 bundle 运行一个容器，后者规定了如何制作一个符合 OCI 标准的镜像。两份标准都可在其官方仓库中看到。本系列重点关注容器运行时。</p><h3 id=runtime-spec class=headerLink><a href=#runtime-spec class=header-mark></a>runtime spec</h3><p>runtime spec 记录了一个容器的配置、执行环境以及生命周期。一个容器的配置用 <code>config.json</code> 文件描述，指定了支持的平台以及创建容器所需的所有字段。容器的执行环境是确保运行在容器中的应用在不同的运行时之间拥有一致的执行环境，同时为容器的生命周期定义了一些常见的操作。</p><p>当前 OCI runtime spec 定义的平台有：</p><ul><li>Linux</li><li>solaris</li><li>windows</li><li>vm</li><li>zos</li></ul><p>不同的运行时中，容器有不同的表现形式。例如 Linux 平台的 runC 运行时创建的容器其实就是普通的进程，而 vm 平台的 gVisor 和 kata 项目中创建的容器是虚拟机。</p><p>后续文章会详细描述遇到的相关 runtime spec，此处不再详细描述整个 runtime spec。</p><h2 id=创建-runtime-spec class=headerLink><a href=#%e5%88%9b%e5%bb%ba-runtime-spec class=header-mark></a>创建 runtime spec</h2><p>runc 命令的 <code>spec</code> 子命令用来创建一个默认配置的运行时配置文件，其子命令实例 <code>specCommand</code> 位于 <code>spec.go</code> 文件中。实例中的 <code>Description</code> 字段中有很详细的介绍，此处不再重复。接下来从 <code>Action</code> 成员开始分析 <code>spec</code> 命令的实现过程。注意目前暂不考虑 rootless 容器的实现，因此分析中会忽略与 rootless 容器相关的代码。</p><h2 id=spec-子命令的具体实现 class=headerLink><a href=#spec-%e5%ad%90%e5%91%bd%e4%bb%a4%e7%9a%84%e5%85%b7%e4%bd%93%e5%ae%9e%e7%8e%b0 class=header-mark></a>spec 子命令的具体实现</h2><p>首先从 <code>specCommand</code> 结构体实例的 <code>Action</code> 成员分析整体流程：</p><ul><li>调用 <code>checkArgs()</code> 函数检查命令行参数的合法性。</li><li>调用 <code>specconv.Example()</code> 函数创建一个默认配置的 <code>specs.Spec</code> 结构体实例。所有与 runtime spec 相关的代码都在 <code>specconv</code> 包中。</li><li>检查当前目录或者 <code>--bundle</code> 参数指定的目录下是否存在 <code>config.json</code> 文件，存在则报错并退出。</li><li>将默认配置的 <code>specs.Spec</code> 结构体实例反序列化成 JSON 字符串写入到 <code>config.json</code> 文件中。</li></ul><h3 id=runc-的运行时目录 class=headerLink><a href=#runc-%e7%9a%84%e8%bf%90%e8%a1%8c%e6%97%b6%e7%9b%ae%e5%bd%95 class=header-mark></a>runC 的运行时目录</h3><p>不启用 rootless 时，默认的运行时目录为 <code>/run/runc</code>。可通过 <code>--root</code> 全局参数指定运行时目录。runC 会把容器运行时相关的文件保存在这个目录中。</p><h3 id=容器的格式 class=headerLink><a href=#%e5%ae%b9%e5%99%a8%e7%9a%84%e6%a0%bc%e5%bc%8f class=header-mark></a>容器的格式</h3><p>为了描述容器的格式，标准定义了一个叫做 <code>filesystem bundle</code> 的概念：以某种方式组织的一系列文件，包含兼容任一运行时所需的所有数据和元数据，以执行针对容器的所有标准操作。</p><p>一个标准的容器 bundle 应该包含以下内容：</p><ul><li>一个 <code>config.json</code> 文件，其中包含了完整的 runtime spec。标准要求这个文件必须放在 bundle 的根目录下，且文件名必须为 <code>config.json</code>。</li><li>容器的根文件系统。根文件系统目录由 <code>config.json</code> 中的 <code>root.path</code> 字段指定，缺省值为 <code>rootfs</code>。</li></ul><p>有关容器格式的更详细内容参考标准文档<sup id=fnref:3><a href=#fn:3 class=footnote-ref role=doc-noteref>3</a></sup>。</p><h3 id=用来描述-runtime-spec-的结构体-specsspec class=headerLink><a href=#%e7%94%a8%e6%9d%a5%e6%8f%8f%e8%bf%b0-runtime-spec-%e7%9a%84%e7%bb%93%e6%9e%84%e4%bd%93-specsspec class=header-mark></a>用来描述 runtime spec 的结构体 specs.Spec</h3><p>runtime-spec 官方仓库中的 <code>specs-go</code> 目录下定义了用来描述 runtime spec 的结构体 <code>specs.Spec</code>。对照 runtime spec 的文档可以很清楚地知道每个字段的含义，此处不再重复。</p><h3 id=runc-的默认-runtime-spec class=headerLink><a href=#runc-%e7%9a%84%e9%bb%98%e8%ae%a4-runtime-spec class=header-mark></a>runC 的默认 runtime spec</h3><p>从 <code>specconv.Example()</code> 函数中可以看到默认的 runtime spec 配置：</p><ul><li>容器的根目录为 <code>bundle</code> 目录下的 <code>rootfs</code> 目录，并且是只读的。</li><li>容器启动时执行的程序为 <code>sh</code>。</li><li>环境变量只有 <code>PATH</code> 和 <code>TERM</code>。</li><li>容器启动时进程的当前工作目录为 <code>/</code>。</li><li>容器中的进程被设置 <code>no_new_privileges</code> 选项。</li><li>容器中的进程拥有的 capabilities 有：<ul><li>Bounding：<ul><li><code>CAP_AUDIT_WRITE</code></li><li><code>CAP_KILL</code></li><li><code>CAP_NET_BIND_SERVICE</code></li></ul></li><li>Permitted：<ul><li><code>CAP_AUDIT_WRITE</code></li><li><code>CAP_KILL</code></li><li><code>CAP_NET_BIND_SERVICE</code></li></ul></li><li>Ambient：<ul><li><code>CAP_AUDIT_WRITE</code></li><li><code>CAP_KILL</code></li><li><code>CAP_NET_BIND_SERVICE</code></li></ul></li><li>Effective：<ul><li><code>CAP_AUDIT_WRITE</code></li><li><code>CAP_KILL</code></li><li><code>CAP_NET_BIND_SERVICE</code></li></ul></li></ul></li><li>容器中的 hostname 为 <code>runc</code>。</li><li>向容器中挂载的目录有：<ul><li><code>/proc</code></li><li><code>/dev</code></li><li><code>/dev/pts</code></li><li><code>/dev/shm</code></li><li><code>/dev/mqueue</code></li><li><code>/sys</code></li><li><code>/sys/fs/cgroup</code></li></ul></li><li>被屏蔽的路径有：<ul><li><code>/proc/acpi</code></li><li><code>/proc/asound</code></li><li><code>/proc/kcore</code></li><li><code>/proc/keys</code></li><li><code>/proc/latency_stats</code></li><li><code>/proc/timer_list</code></li><li><code>/proc/timer_stats</code></li><li><code>/proc/sched_debug</code></li><li><code>/proc/firmware</code></li><li><code>/proc/scsi</code></li></ul></li><li>只读路径有：<ul><li><code>/proc/bus</code></li><li><code>/proc/fs</code></li><li><code>/proc/irq</code></li><li><code>/proc/sys</code></li><li><code>/proc/sysrq-trigger</code></li></ul></li><li>为容器单独创建所有的命名空间。</li></ul><div class=footnotes role=doc-endnotes><hr><ol><li id=fn:1><p><a href=https://github.com/opencontainers/runtime-spec target=_blank rel="noopener noreffer">https://github.com/opencontainers/runtime-spec</a>&#160;<a href=#fnref:1 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:2><p><a href=https://github.com/opencontainers/image-spec target=_blank rel="noopener noreffer">https://github.com/opencontainers/image-spec</a>&#160;<a href=#fnref:2 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:3><p><a href=https://github.com/opencontainers/runtime-spec/blob/27924127bf391ea7691924c6dcb01f3369d69fe2/bundle.md target=_blank rel="noopener noreffer">https://github.com/opencontainers/runtime-spec/blob/27924127bf391ea7691924c6dcb01f3369d69fe2/bundle.md</a>&#160;<a href=#fnref:3 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li></ol></div></div><div class=post-footer id=post-footer><div class=post-info><div class=post-info-line><div class=post-info-mod><span></span></div><div class=post-info-license></div></div><div class=post-info-line><div class=post-info-md></div><div class=post-info-share><span></span></div></div></div><div class=post-info-more><section class=post-tags><i class="fas fa-tags fa-fw"></i>&nbsp;<a href=/tags/linux/>Linux</a>,&nbsp;<a href=/tags/container/>Container</a>,&nbsp;<a href=/tags/cloud-native/>Cloud Native</a></section><section><span><a href=javascript:void(0); onclick=window.history.back()></a></span>&nbsp;|&nbsp;<span><a href=/></a></span></section></div><div class=post-nav><a href=/posts/read-source-code-of-runc-prepare-environment/ class=prev rel=prev title="准备 runC 源码环境"><i class="fas fa-angle-left fa-fw"></i>准备 runC 源码环境</a></div></div><div id=comments><div id=gitalk class=comment></div><noscript>Please enable JavaScript to view the comments powered by <a href=https://github.com/gitalk/gitalk></a>Gitalk</a>.</noscript></div></article></div></main><footer class=footer><div class=footer-container><div class=footer-line>由 Hugo 强力驱动</div><div class=footer-line>&nbsp;|&nbsp;</div><div class=footer-line><i class="far fa-copyright fa-fw"></i><span itemprop=copyrightYear>2022</span><span class=author itemprop=copyrightHolder>&nbsp;<a href=/ target=_blank rel="noopener noreferrer"></a></span>&nbsp;|&nbsp;<span class=license><a rel="license external nofollow noopener noreffer" href=https://creativecommons.org/licenses/by-nc/4.0/ target=_blank>CC BY-NC 4.0</a></span></div><div class=footer-line></div><div class=footer-line></div></div></footer></div><div id=fixed-buttons><a href=#back-to-top id=back-to-top-button class=fixed-button title><i class="fas fa-arrow-up fa-fw"></i>
</a><a href=# id=view-comments class=fixed-button title><i class="fas fa-comment fa-fw"></i></a></div><div class=assets><script type=text/javascript src=/lib/lazysizes/lazysizes.min.js></script><script type=text/javascript src=/lib/topbar/topbar.min.js></script><script type=text/javascript src=/lib/pjax/pjax.min.js></script><script type=text/javascript src=/js/theme.min.js defer></script></div><div class=pjax-assets><script type=text/javascript>window.config={code:{copyTitle:"",maxShownLines:50},comment:{gitalk:{admin:["NitroCao"],clientID:"94646e9139c4cfbac497",clientSecret:"0fda151ceb53b61ce441679301c2e558c2ffb86b",id:"2022-05-18T21:18:12+08:00",owner:"NitroCao",repo:"nitrocao.github.io",title:"spec 子命令的实现"}}}</script><script type=text/javascript src=/lib/gitalk/gitalk.min.js></script><script type=text/javascript src=/js/gitalk.min.js defer></script><script type=text/javascript src=/lib/clipboard/clipboard.min.js></script><link rel=stylesheet href=/lib/gitalk/gitalk.min.css></div></body></html>